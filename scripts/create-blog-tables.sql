CREATE TABLE IF NOT EXISTS blog_posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  title TEXT NOT NULL,
  excerpt TEXT,
  content TEXT,
  author TEXT,
  image TEXT,
  category TEXT,
  read_time TEXT,
  date TEXT,
  featured BOOLEAN DEFAULT FALSE,
  status TEXT DEFAULT 'draft', -- 'draft' or 'published'
  views INT DEFAULT 0
);

-- Enable Row Level Security (RLS)
ALTER TABLE blog_posts ENABLE ROW LEVEL SECURITY;

-- Policy for public access (read-only for published posts)
CREATE POLICY "Enable read access for all users" ON blog_posts
FOR SELECT USING (status = 'published');

-- Policy for admin access (full CRUD for authenticated users)
-- You might want to refine this based on specific user roles
CREATE POLICY "Enable full access for authenticated users" ON blog_posts
FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

-- Optional: Create a function to update `updated_at` automatically
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Optional: Create a trigger to call the function on update
CREATE OR REPLACE TRIGGER update_blog_posts_updated_at
BEFORE UPDATE ON blog_posts
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
